:PROPERTIES:
:ID:       c20af4a4-17d6-40c4-8f2c-d1c1766944b8
:END:
#+TITLE: ls
#+AUTHOR: Chris Boette @chrisbodhi
#+DATE: 23 August 12021
#+auto_tangle: t

#+begin_quote
Please implement a minimal clone of the =ls= program. We have chosen this exercise as it will require you to use structs, pointers and arrays, as well as some C standard library functions with interesting interfaces. It will also likely to be substantial enough to merit some degree of code organization.

Minimally, it should list the contents of a directory including some information about each file, such as file size. As a stretch goal, use =man ls= to identify any interesting flags you may wish to support, and implement them.
#+end_quote


To begin, let's include the headers from the standard library that we'll need. This will allow us to access functions that ship with C, but are separate from the core functionality of the language.

#+begin_src C :tangle cb-ls.c :main no
#include <dirent.h>
#include <stdio.h>
#include <errno.h>
#+end_src

Next, we'll set up our =main= function, which will be called when our executable is called with =cb-ls=. We'll start with returning =0= to signal that we exited without any issues.

#+begin_src C
int main() {
  printf("here we are...\n");
  return 0;
}
#+end_src

Then, we'll start to rough out the function that will do the bulk of the work, =ls=.

#+begin_src C
void ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);
}
#+end_src

Next up, we declare =ls= and then call that sucker.

#+begin_src C :tangle cb-ls.c
void ls(char *tolist);

int main(int argc, char *argv[]) {
  char *dir;

  if (argc == 2) {
      dir = argv[1];
  } else {
      dir = "./";
  }

  ls(dir);
  return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls

| .          |
| ..         |
| cb-ls      |
| README.org |
| cb-ls.c    |
#+end_src

Which work! This is great! But, it doesn't handle bad input. :/

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

[1]    34877 segmentation fault  ./cb-ls ../not/a/directory
#+end_src

Let's tighten that shit up.

We need to be able to handle the different kinds of errors, as outlined in some random-ass GNU libc PDF.

Let's start with =opendir= having trouble with creating a stream from the passed-in directory name. When it fails, it returns a null pointer, so we check for that.

#+begin_src C :tangle cb-ls.c
int ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    if (d == NULL) {
        printf("Cannot open %s\nDoes that directory exist?\n", tolist);
        return 1;
    }

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);

    return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

Cannot open ../not/a/directory
Does that directory exist?
#+end_src

Excellent. Note that we've also change the function's return type from =void= to =int=, so that when we error, we can return a non-zero exit code. This is a convention that signifies our program has run into an error.

** Meta notes
- Development is done using org-mode's tangle functionality, which allows for interleaving source code and plain text notes, without having to write those notes as comments in the source code. A library (for convenience) has been added, so that an updated, source code file is created on each save: [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]]
- To run the tangled file when it's created, =wach= is running the command ~$ wach "gcc -o cb-ls cb-ls.c && ./cb-ls"~ to compile and execute the file on each change: [[https://github.com/quackingduck/wach][wach]]
- =vterm= is being used in Emacs to see the output directly next to the literate file: [[https://github.com/akermu/emacs-libvterm][libvterm]]
