:PROPERTIES:
:ID:       c20af4a4-17d6-40c4-8f2c-d1c1766944b8
:END:
#+TITLE: ls
#+AUTHOR: Chris Boette @chrisbodhi
#+DATE: 23 August 12021
#+auto_tangle: t

#+begin_quote
Please implement a minimal clone of the =ls= program. We have chosen this exercise as it will require you to use structs, pointers and arrays, as well as some C standard library functions with interesting interfaces. It will also likely to be substantial enough to merit some degree of code organization.

Minimally, it should list the contents of a directory including some information about each file, such as file size. As a stretch goal, use =man ls= to identify any interesting flags you may wish to support, and implement them.
#+end_quote


To begin, let's include the headers from the standard library that we'll need. This will allow us to access functions that ship with C, but are separate from the core functionality of the language.

#+begin_src C :tangle cb-ls.c :main no
#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#+end_src

Next, we'll set up our =main= function, which will be called when our executable is called with =cb-ls=. We'll start with returning =0= to signal that we exited without any issues.

#+begin_src C
int main() {
  printf("here we are...\n");
  return 0;
}
#+end_src

Then, we'll start to rough out the function that will do the bulk of the work, =ls=. After opening a stream for the requested directory, we go to the =while= loop, where we read the next directory (until there isn't one left; hence, the null check). The directory is represented by a struct(ure), from which we can take the =d_name= property to print out.

#+begin_src C
int ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);

    return 0;
}
#+end_src

Next up, we declare =ls= and then call that sucker.

#+begin_src C
int ls(char *tolist);

int main(int argc, char *argv[]) {
  char *dir;

  if (argc == 2) {
      dir = argv[1];
  } else {
      dir = "./";
  }

  ls(dir);
  return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls

| .          |
| ..         |
| cb-ls      |
| README.org |
| cb-ls.c    |
#+end_src

Which works! This is great! But, it doesn't handle bad input. :/

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

[1]    34877 segmentation fault  ./cb-ls ../not/a/directory
#+end_src

Let's tighten that shit up.

We need to be able to handle the different kinds of errors, as outlined in some random-ass GNU libc PDF.

Let's start with =opendir= having trouble with creating a stream from the passed-in directory name. When it fails, it returns a null pointer, so we check for that.

#+begin_src C
int ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    if (d == NULL) {
        printf("Cannot open %s\nDoes that directory exist?\n", tolist);
        return 1;
    }

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);

    return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

Cannot open ../not/a/directory
Does that directory exist?
#+end_src

Excellent. Note that when we error, we return a non-zero exit code. This is a convention that signifies our program has run into an error.

Before we get too much further into error handling, let's revist the functionality of our =ls= clone. Compared to =ls=, there are a couple of defaults we're doing differently, and not for any good reason. So, let's fix those: displaying =.= and =..=, and not sorting our results. Let's start with those dots, which represent links to the current directory (=.=) and parent directory (=..=).

To remove the links, we could set up an =if= check around our =printf= statement, making sure that no files start with a =.=, but...

#+begin_src C
while((l = readdir(d)) != NULL) {
  char name = l->d_name;
  if (strncmp(name, ".", 1) != 0) {
    printf("%s\n", l->d_name);
  }
}
#+end_src

...that discards any other information about the directory entry at each step through the loop. Also, this approach excludes any hidden files, in a hardcoded way. So, let's start with splitting apart our existing code into smaller parts which each part addresses one concern.

At a high level:
- Get the file names and inodes
- Filter to what the user wants to see
- Format the information
- Sort it, to then...
- Present what the user wants to see

** Get the file names and inodes

=inodes= is a new term here. Our way of reading the contents of a directory yields not a lot of information -- namely, the filename and its serial number. (WHERE DO WE GET THE RANK? :troll: ) We can take that serial number, though, and look up some more information, if the user requests it. For this step, we'll just collect the information in an array.

#+begin_src C :tangle cb-ls.c
#define LOTS 2000

struct cb_dir {
        ino_t ino;
        char* name;
    } cb_dirs[LOTS];

// params: directory to open, empty array (pointer to start of array), pointer to current length of array
void getdirs(char *, struct cb_dir *, int *);

int main() {
    int i;
    int *ip;

    i = 0;
    ip = &i;
    getdirs(".", cb_dirs, ip);
    printf("len is %d, and first name is...%s.\n", i, cb_dirs[0].name);
    printf("len is %d, and fifth name is...%s.\n", i, cb_dirs[4].name);
    printf("len is %d, and last name is...%s.\n", i, cb_dirs[i - 1].name);
    if (i > LOTS) {
        fprintf(stderr, "More dirs than slots for dirs.");
        return 1;
    }
    return 0;
}

void getdirs(char *dirstr, struct cb_dir *dirs, int *ip) {
    DIR *d;
    struct dirent *l;

    d = opendir(dirstr);

    while((l = readdir(d)) != NULL) {
        struct cb_dir dir = { l->d_fileno, l->d_name };
        ,*dirs = dir;
        dirs++;
        (*ip)++;
    }
}
#+end_src

#+begin_src sh
./cb-ls

#+RESULTS:
 len is 11 and first name is...README.org.
#+end_src

Our =getdirs= function not only updates the =cb_dirs= array, but also keeps track of the current length by updating a pointer.


** Filter to what the user wants to see

Let's start with skipping all of the items that start with a =.=, or are hidden. We'll keep the logic to do this in a helper function, so we can selectively apply it later, as needed.

#+begin_src C
void removehidden(void *arr);

void removehidden(void *arr) {
    char* starts = ".";
    int i = 0;
    while (arr[i] != NULL) {
        if (arr[i].name[0] == starts) {
            printf("oh snap\n");
        }
        i++;
    }
}

removehidden();
#+end_src

** Meta notes
- Development is done using org-mode's tangle functionality, which allows for interleaving source code and plain text notes, without having to write those notes as comments in the source code. A library (for convenience) has been added, so that an updated, source code file is created on each save: [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]]
- To run the tangled file when it's created, =wach= is running the command ~$ wach "gcc -o cb-ls cb-ls.c && ./cb-ls"~ to compile and execute the file on each change: [[https://github.com/quackingduck/wach][wach]]
- =vterm= is being used in Emacs to see the output directly next to the literate file: [[https://github.com/akermu/emacs-libvterm][libvterm]]
