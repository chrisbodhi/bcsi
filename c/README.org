:PROPERTIES:
:ID:       c20af4a4-17d6-40c4-8f2c-d1c1766944b8
:END:
#+TITLE: ls
#+AUTHOR: Chris Boette @chrisbodhi
#+DATE: 23 August 12021
#+auto_tangle: t

#+begin_quote
Please implement a minimal clone of the =ls= program. We have chosen this exercise as it will require you to use structs, pointers and arrays, as well as some C standard library functions with interesting interfaces. It will also likely to be substantial enough to merit some degree of code organization.

Minimally, it should list the contents of a directory including some information about each file, such as file size. As a stretch goal, use =man ls= to identify any interesting flags you may wish to support, and implement them.
#+end_quote


To begin, let's include the headers from the standard library that we'll need. This will allow us to access functions that ship with C, but are separate from the core functionality of the language.

#+begin_src C :tangle cb-ls.c :main no
#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#+end_src

Next, we'll set up our =main= function, which will be called when our executable is called with =cb-ls=. We'll start with returning =0= to signal that we exited without any issues.

#+begin_src C
int main() {
  printf("here we are...\n");
  return 0;
}
#+end_src

Then, we'll start to rough out the function that will do the bulk of the work, =ls=. After opening a stream for the requested directory, we go to the =while= loop, where we read the next directory (until there isn't one left; hence, the null check). The directory is represented by a struct(ure), from which we can take the =d_name= property to print out.

#+begin_src C
int ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);

    return 0;
}
#+end_src

Next up, we declare =ls= and then call that sucker.

#+begin_src C :tangle cb-ls.c
int ls(char *tolist);

int main(int argc, char *argv[]) {
  char *dir;

  if (argc == 2) {
      dir = argv[1];
  } else {
      dir = "./";
  }

  ls(dir);
  return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls

| .          |
| ..         |
| cb-ls      |
| README.org |
| cb-ls.c    |
#+end_src

Which works! This is great! But, it doesn't handle bad input. :/

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

[1]    34877 segmentation fault  ./cb-ls ../not/a/directory
#+end_src

Let's tighten that shit up.

We need to be able to handle the different kinds of errors, as outlined in some random-ass GNU libc PDF.

Let's start with =opendir= having trouble with creating a stream from the passed-in directory name. When it fails, it returns a null pointer, so we check for that.

#+begin_src C :tangle cb-ls.c
int ls(char *tolist) {
    DIR *d;
    struct dirent *l;

    d = opendir(tolist);

    if (d == NULL) {
        printf("Cannot open %s\nDoes that directory exist?\n", tolist);
        return 1;
    }

    while((l = readdir(d)) != NULL) {
        printf("%s\n", l->d_name);
    }
    closedir(d);

    return 0;
}
#+end_src

#+begin_src sh
~/code/bcsi3/c/cb-ls ../not/a/directory

Cannot open ../not/a/directory
Does that directory exist?
#+end_src

Excellent. Note that when we error, we return a non-zero exit code. This is a convention that signifies our program has run into an error.

Before we get too much further into error handling, let's revist the functionality of our =ls= clone. Compared to =ls=, there are a couple of defaults we're doing differently, and not for any good reason. So, let's fix those: displaying =.= and =..=, and not sorting our results. Let's start with those dots, which represent links to the current directory (=.=) and parent directory (=..=).

To remove the links, we could set up an =if= check around our =printf= statement, making sure that no files start with a =.=, but...

#+begin_src C
while((l = readdir(d)) != NULL) {
  char name = l->d_name;
  if (strncmp(name, ".", 1) != 0) {
    printf("%s\n", l->d_name);
  }
}
#+end_src

...that discards any other information about the directory entry at each step through the loop. Also, this approach excludes any hidden files, in a hardcoded way.




** Meta notes
- Development is done using org-mode's tangle functionality, which allows for interleaving source code and plain text notes, without having to write those notes as comments in the source code. A library (for convenience) has been added, so that an updated, source code file is created on each save: [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]]
- To run the tangled file when it's created, =wach= is running the command ~$ wach "gcc -o cb-ls cb-ls.c && ./cb-ls"~ to compile and execute the file on each change: [[https://github.com/quackingduck/wach][wach]]
- =vterm= is being used in Emacs to see the output directly next to the literate file: [[https://github.com/akermu/emacs-libvterm][libvterm]]
